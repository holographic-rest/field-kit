# Core Data Objects v0.1

## 1) Front Matter

* **Title:** Core Data Objects v0.1
* **Version:** v0.1
* **Date:** 2025-12-16
* **Status:** Draft
* **Suggested repo path:** `/docs/specs/02_core_data_objects_v0.1.md`

## 2) Purpose

These core objects define the **persistent Field** for v0.1: a Blank Field where users create Items, draft/execute Bonds, and run Holologue to generate **specific artifact Items** (general→specific). Together, these objects enable: (1) durable state (Items/Bonds/Episodes/Networks), (2) **lineage/provenance** for generated outputs, (3) the operator loop (Bond execution and Holologue runs), and (4) an append-only **Ledger** via immutable QDPIEvents for audit, replay, and debugging.

### Terms (v0.1)

* **Episode:** A local, user-owned container for one working session. Every persisted object and every QDPIEvent belongs to exactly one Episode via `episode_id`.
* **Item:** A persistent node of content in the Field, created by a user or generated by an operator. Items are addressable by ID and include a `type` (e.g., `Q`, `M`, `D`, `H`) plus content and minimal metadata.
* **Bond:** A persistent instruction that connects one or more input Items to an operator run. `prompt_text` is the primary instruction. Bonds are created as `status:"draft"` and may be executed; execution generates exactly one output Item and MUST set `status:"executed"` and `output_item_id`.
* **QDPIEvent:** An append-only event record that logs meaningful actions and results. Each event includes `qdpi` (Queue/Monologue/Dialogue/Holologue), `direction` (user→field or system→field), a `name`, a timestamp, and refs to related object IDs.
* **Proposal:** A system suggestion (e.g., suggested Bond prompts) that is logged as events only until the user explicitly confirms creation.
* **Canon:** A user-curated projection over Items/Bonds within an Episode used for presentation or replay. Canon never overrides the append-only event log.
* **Bundle:** A structured artifact output of a Holologue run (many→one) capturing what was selected, what was generated, and any optional proposals. A Bundle may be represented as a single output Item plus an exportable JSON payload.

### Scope and Non-goals (v0.1)

* v0.1 is **Private • Local**: no accounts, no cloud sync, no collaboration, no publishing.
* This doc defines the **persistent objects** (Network, Episode, Item, Bond) and the **append-only event log** (QDPIEvent) for a **Blank Field MVP** local store.
* UI flows, onboarding copy, and operator UX are out of scope here except where needed to define event names and invariants.

## 3) Design Principles

* **Blank Field only (v0.1):** no world imports/corpora; all objects originate locally.
* **Append-only events are the audit trail:** QDPIEvent is immutable; corrections are new events.
* **Bonds are prompt + connector (one object):** a Bond stores inputs, prompt text, execution status, and output linkage.
* **Bond execution produces lineage:** executed Bonds must point to an output Item, and output Items must reference their origin.
* **Holologue is general→specific:** Holologue produces **one concrete artifact Item** from a constellation (not summary-by-default).
* **Provenance is first-class:** every generated Item must carry minimal provenance sufficient for audit and “why/how was this made?”
* **User confirmation is required for structure:** user creates Items; user confirms Bond drafts and initiates execution.
* **Multi-purpose by design:** operators are not domain-locked (works for science, creative, planning, research).
* **Strict enough to ship now:** schemas and invariants are enforceable in an MVP store.
* **Extensible later without breaking:** prefer additive fields, enums with escape hatches, and stable IDs.
* **Denormalize intentionally for v0.1:** store `network_id` and `episode_id` on most objects for easy queries.
* **Log meaning, not paint:** by default, events capture state changes and key inspections; render/paint events are debug-only. In v0.1, direction `field→user` render/paint/layout events are NOT logged by default; if captured at all, they MUST be marked `is_debug: true`.

### Credits (v0.1 simulation; derived from events)

* Credits are **local-only** and **purely simulated** in v0.1.
* Credits are **not transferable**, **not redeemable**, and have **no USD exchange rate** in v0.1.
* Credits are **not** a new core object in v0.1; Credits are represented as **QDPIEvents** and computed into a balance as a **derived view**.

**Standard event pattern (single pattern for v0.1):**

* Event name: `credits.delta`
* Stored as a QDPIEvent with `refs` containing:

  * `delta` (integer; positive or negative)
  * `balance_after` (integer)
  * `reason` (short string; e.g., `seed`, `item_created`, `bond_executed`, `holologue_completed`)
  * optional `related` object refs (e.g., `item_id`, `bond_id`, `qdpi_event_id`)

**Recommended defaults (v0.1):**

* `qdpi` SHOULD usually be **Queue** (`"Q"`) because it is bookkeeping.
* `direction` SHOULD usually be `system→field` because the system records the delta after an action completes.

## 4) Naming + ID Conventions

### ID format

* **Recommended:** ULID strings (time-sortable, collision-resistant).
* **Uniqueness rule:** IDs must be globally unique within a local store (across all files/tables).

### Prefixes (required)

* `ep_` Episode
* `it_` Item
* `bd_` Bond
* `nw_` Network
* `ev_` QDPIEvent

### Ordering guarantees

* **QDPIEvent ordering:** events are ordered by `(episode_id, seq)` ascending.

  * `seq` is a monotonically increasing integer per episode, starting at `1`.
  * If `seq` is missing during early prototyping, fall back to ULID sort, but v0.1 implementations SHOULD include `seq`.

### Example IDs (reused across this document)

All JSON examples below reuse this single ID set:

* `network_id`: `nw_01JFA3K8P2K8R3X3N9V0V6B9TQ`
* `episode_id`: `ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z`
* `it_q1`: `it_01JFA3KB2Q4P6D4X9H2ZK8N3AA`
* `it_q2`: `it_01JFA3KQ9C2L1M7V8B0N3H5J2PP`
* `bd_1`: `bd_01JFA3KJ7V3J1QZ1R2N0F0G8TT`
* `it_m1`: `it_01JFA3KS1Q0W4Z8R6M9N2B7C3DD`
* `it_h1`: `it_01JFA3M6Z8Y1Q2W3E4R5T6U7IV`
* `ev_first_run_started`: `ev_01JFA3K9A1B2C3D4E5F6G7H8J`
* `ev_bond_executed`: `ev_01JFA3KS9B1N2B3C4D5E6F7G8H9`
* `ev_holologue_completed`: `ev_01JFA3M2D4R7P1X9K8V0N2T6QA`
* `ev_credits_delta`: `ev_01JFA3M0C9R3D1T5D3LTA0001`

## 5) Enumerations

```ts
// QDPI tag values stored on QDPIEvent (UI can render full names: Queue/Monologue/Dialogue/Holologue)
export type QDPI = "Q" | "M" | "D" | "H";

// Item.type is a simple "mode label" for v0.1 to support tutorial flows and operator outputs.
// It is not mystical: it categorizes the *role* of the Item in the operator loop.
export type ItemType = "Q" | "M" | "D" | "H";

// Scope is included now to avoid schema breaks later.
// v0.1 behavior: only "private" is implemented.
export type Scope = "private" | "shared" | "public";

// Bond lifecycle (v0.1):
// - status is either draft or executed
// - failures do NOT introduce a third status; we keep draft and record last_error.
// Justification: keeps the state machine minimal while still surfacing failure details.
export type BondStatus = "draft" | "executed";

// Holologue artifact hints (small presets + allow custom string)
export type ArtifactKindPreset = "plan" | "experiment" | "checklist" | "spec_fragment" | "story_beat";
export type ArtifactKind = ArtifactKindPreset | (string & {});

// Actor model (minimal, extensible)
export type ActorKind = "user" | "system" | "agent";
```

## 6) Object Specifications

### Shared Types (used by multiple objects)

```ts
export type ISO8601 = string; // e.g. "2025-12-16T00:00:12.940Z"

export type Vec3 = { x: number; y: number; z: number };

export type ActorRef = {
  kind: ActorKind;           // REQUIRED
  id?: string;               // OPTIONAL (e.g. "local-user", "system", "agent:xyz")
  display?: string;          // OPTIONAL (UI label)
};

export type ErrorInfo = {
  message: string;           // REQUIRED (human readable)
  code?: string;             // OPTIONAL (machine readable)
  at: ISO8601;               // REQUIRED
  detail?: unknown;          // OPTIONAL (debug payload; avoid PII)
};
```

---

## 6.1) Item

### A) Purpose

An Item is the **atomic persistent artifact** in the Field. Items can be user-created or generated by operators (Bond execution outputs, Holologue artifacts). Items are spatial (positioned in the Field), editable (workshop-style), and can carry minimal provenance sufficient for audit/replay.

### B) Schema (required vs optional fields, typed)

```ts
export type ItemProvenance =
  | {
      created_by: "user" | "system";
      // For user/system-created items, provenance may be minimal.
    }
  | {
      created_by: "bond";
      bond_id: string;              // REQUIRED
      input_item_ids: string[];     // REQUIRED (copied at creation time)
    }
  | {
      created_by: "holologue";
      holologue_event_id: string;   // REQUIRED (ev_...)
      selected_item_ids: string[];  // REQUIRED (copied at creation time)
      artifact_kind: ArtifactKind;  // REQUIRED
    };

export type Item = {
  schema_version: 1;                // REQUIRED

  id: string;                       // REQUIRED (it_...)
  network_id: string;               // REQUIRED (nw_...)
  episode_id: string;               // REQUIRED (ep_...)

  scope: Scope;                     // REQUIRED (v0.1: "private")
  type: ItemType;                   // REQUIRED ("Q" | "M" | "D" | "H")

  title: string;                    // REQUIRED (non-empty)
  body?: string;                    // OPTIONAL

  position: Vec3;                   // REQUIRED (store explicitly; default {0,0,0})

  provenance: ItemProvenance;       // REQUIRED

  created_at: ISO8601;              // REQUIRED
  updated_at: ISO8601;              // REQUIRED
  archived_at?: ISO8601;            // OPTIONAL (soft-hide; not deletion)

  created_by_actor?: ActorRef;      // OPTIONAL (who authored creation)
};
```

**REQUIRED fields:** `schema_version, id, network_id, episode_id, scope, type, title, position, provenance, created_at, updated_at`
**OPTIONAL fields:** `body, archived_at, created_by_actor`

### C) Invariants / validation rules

* `id` MUST start with `it_` and be unique.
* `title` MUST be non-empty after trimming.
* `scope` MUST be `"private"` in v0.1 runtime enforcement (enum allows future values).
* `position` MUST contain finite numbers (no `NaN`, no `Infinity`).
* `provenance.created_by` governs required fields:

  * If `created_by === "bond"`: `bond_id` and `input_item_ids.length >= 1` required.
  * If `created_by === "holologue"`: `holologue_event_id` and `selected_item_ids.length >= 2` required; `artifact_kind` required.
* `created_at <= updated_at` (lexicographically as ISO8601 timestamps).
* Provenance fields are **immutable** once the Item is created.

### D) Typical lifecycle (created, updated, archived; what is immutable)

* **Created:** by user (Q) or by operator (Bond output M/D, Holologue artifact H).
* **Updated:** user may edit `title`, `body`, and `position`; system updates `updated_at`.
* **Archived:** set `archived_at` (Item remains in store).
* **Immutable:** `id`, `network_id`, `episode_id`, and `provenance` MUST NOT change after creation.

### E) Indexing/query keys

* `network_id`, `episode_id`
* `type`
* `updated_at` (recent activity)
* `archived_at` (hide archived)
* Provenance queries:

  * `provenance.created_by`
  * `provenance.bond_id` (find all outputs of a Bond)
  * `provenance.holologue_event_id` (find Holologue output)

### F) Example JSON objects (2+)

**Example 1 — User-created Q Item**

```json
{
  "schema_version": 1,
  "id": "it_01JFA3KB2Q4P6D4X9H2ZK8N3AA",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "scope": "private",
  "type": "Q",
  "title": "My First Field Item",
  "body": "What do I want to explore here?",
  "position": { "x": 0, "y": 0, "z": 0 },
  "provenance": { "created_by": "user" },
  "created_at": "2025-12-16T00:00:12.901Z",
  "updated_at": "2025-12-16T00:00:12.901Z",
  "created_by_actor": { "kind": "user", "id": "local-user", "display": "You" }
}
```

**Example 2 — Bond output Item (Q→M)**

```json
{
  "schema_version": 1,
  "id": "it_01JFA3KS1Q0W4Z8R6M9N2B7C3DD",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "scope": "private",
  "type": "M",
  "title": "Minimal experiment",
  "body": "Outcome: ...\nVariable: ...\nProtocol:\n1) ...\n2) ...\n3) ...",
  "position": { "x": 1.4, "y": 0.2, "z": 0 },
  "provenance": {
    "created_by": "bond",
    "bond_id": "bd_01JFA3KJ7V3J1QZ1R2N0F0G8TT",
    "input_item_ids": ["it_01JFA3KB2Q4P6D4X9H2ZK8N3AA"]
  },
  "created_at": "2025-12-16T00:00:26.410Z",
  "updated_at": "2025-12-16T00:00:26.410Z",
  "created_by_actor": { "kind": "system", "id": "system", "display": "Field-Kit" }
}
```

**Example 3 — Holologue artifact Item (many→one, general→specific)**

```json
{
  "schema_version": 1,
  "id": "it_01JFA3M6Z8Y1Q2W3E4R5T6U7IV",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "scope": "private",
  "type": "H",
  "title": "Plan artifact",
  "body": "Goal: ...\nConstraints: ...\nSteps:\n1) ...\n2) ...\n3) ...",
  "position": { "x": 0.6, "y": -1.1, "z": 0 },
  "provenance": {
    "created_by": "holologue",
    "holologue_event_id": "ev_01JFA3M2D4R7P1X9K8V0N2T6QA",
    "selected_item_ids": [
      "it_01JFA3KB2Q4P6D4X9H2ZK8N3AA",
      "it_01JFA3KQ9C2L1M7V8B0N3H5J2PP"
    ],
    "artifact_kind": "plan"
  },
  "created_at": "2025-12-16T00:00:48.210Z",
  "updated_at": "2025-12-16T00:00:48.210Z",
  "created_by_actor": { "kind": "system", "id": "system", "display": "Field-Kit" }
}
```

---

## 6.2) Bond

### A) Purpose

A Bond is a **user-facing object** that is both:

1. a **connector** between input Items (structure), and
2. a **prompt** that can be **executed** to generate a new output Item (operator loop).

Bonds have a minimal lifecycle: `draft → executed`. Executed Bonds MUST set `output_item_id`.

### B) Schema (required vs optional fields, typed)

```ts
export type Bond = {
  schema_version: 1;                // REQUIRED

  id: string;                       // REQUIRED (bd_...)
  network_id: string;               // REQUIRED (nw_...)
  episode_id: string;               // REQUIRED (ep_...)

  scope: Scope;                     // REQUIRED (v0.1: "private")

  // Prompt + connector (one object)
  input_item_ids: string[];         // REQUIRED (>=1, unique)
  prompt_text: string;              // REQUIRED (non-empty)

  // Lifecycle
  status: BondStatus;               // REQUIRED ("draft" | "executed")
  output_item_id: string | null;    // REQUIRED (null when draft; non-null when executed)

  // Optional intent hint for UI and downstream behavior (not required for correctness)
  intent_type?: string;             // OPTIONAL (e.g. "experiment", "plan", "clarify")

  // Execution metadata (minimal)
  executed_at?: ISO8601;            // OPTIONAL (required when executed)
  execution_count?: number;         // OPTIONAL (recommended; >=1 when executed)

  // Failure representation (v0.1): keep draft and set last_error
  last_error?: ErrorInfo;           // OPTIONAL

  created_by: "user" | "system";    // REQUIRED
  created_by_actor?: ActorRef;      // OPTIONAL

  created_at: ISO8601;              // REQUIRED
  updated_at: ISO8601;              // REQUIRED
  archived_at?: ISO8601;            // OPTIONAL
};
```

**REQUIRED fields:** `schema_version, id, network_id, episode_id, scope, input_item_ids, prompt_text, status, output_item_id, created_by, created_at, updated_at`
**OPTIONAL fields:** `intent_type, executed_at, execution_count, last_error, created_by_actor, archived_at`

### C) Invariants / validation rules

* `id` MUST start with `bd_` and be unique.
* `input_item_ids` MUST have length ≥ 1 and contain unique IDs.
* `prompt_text` MUST be non-empty after trimming.
* If `status === "draft"`:

  * `output_item_id` MUST be `null`
  * `executed_at` SHOULD be `undefined`
  * `execution_count` SHOULD be `undefined` or `0` (if stored, MUST be `0`)
* If `status === "executed"`:

  * `output_item_id` MUST be non-null and reference an existing Item
  * `executed_at` MUST be present
  * `execution_count` MUST be present and ≥ 1 (recommended to always store)
* **Immutability after first execution (v0.1 rule):**

  * once `status` becomes `executed`, `input_item_ids` and `prompt_text` MUST NOT change.
  * re-executions (if supported) must keep the same inputs/prompt and only update `output_item_id`, `executed_at`, `execution_count`.
* If `last_error` exists, it MUST NOT contain user secrets; keep to safe debug info.

### D) Typical lifecycle

* **Draft created:** user confirms inputs + prompt (often from 4 suggestions or user-written).
* **Draft updated:** user edits `prompt_text` or inputs (allowed only while draft).
* **Executed:** system runs the Bond, generates an output Item, sets `status:"executed"`, `output_item_id`, `executed_at`, `execution_count`.
* **Re-executed (optional):** if `output_item_id` changes, prior output Items remain in the store with their provenance (history is not deleted).
* **Execution failure:** keep `status:"draft"`, set/update `last_error`, append a failure QDPIEvent.
* **Archived:** set `archived_at` (Bond remains in store).

### E) Indexing/query keys

* `network_id`, `episode_id`
* `status`
* `updated_at`
* `input_item_ids` (contains queries: find all Bonds touching an Item)
* `output_item_id` (reverse lookup)
* `intent_type` (optional UI filters)

### F) Example JSON objects (2)

**Example 1 — Draft Bond created from a suggested prompt**

```json
{
  "schema_version": 1,
  "id": "bd_01JFA3KJ7V3J1QZ1R2N0F0G8TT",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "scope": "private",
  "input_item_ids": ["it_01JFA3KB2Q4P6D4X9H2ZK8N3AA"],
  "prompt_text": "Propose a minimal experiment to probe this.",
  "intent_type": "experiment",
  "status": "draft",
  "output_item_id": null,
  "created_by": "user",
  "created_by_actor": { "kind": "user", "id": "local-user", "display": "You" },
  "created_at": "2025-12-16T00:00:23.120Z",
  "updated_at": "2025-12-16T00:00:23.120Z"
}
```

**Example 2 — Executed Bond (latest output linked)**

```json
{
  "schema_version": 1,
  "id": "bd_01JFA3KJ7V3J1QZ1R2N0F0G8TT",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "scope": "private",
  "input_item_ids": ["it_01JFA3KB2Q4P6D4X9H2ZK8N3AA"],
  "prompt_text": "Propose a minimal experiment to probe this.",
  "intent_type": "experiment",
  "status": "executed",
  "output_item_id": "it_01JFA3KS1Q0W4Z8R6M9N2B7C3DD",
  "executed_at": "2025-12-16T00:00:26.410Z",
  "execution_count": 1,
  "created_by": "user",
  "created_by_actor": { "kind": "user", "id": "local-user", "display": "You" },
  "created_at": "2025-12-16T00:00:23.120Z",
  "updated_at": "2025-12-16T00:00:26.410Z"
}
```

---

## 6.3) Episode

### A) Purpose

An Episode is a **mutable workshop/session container** for v0.1. It groups Items, Bonds, and QDPIEvents via `episode_id` references. Episode 0 (“Session 0”) is auto-created on first launch.

### B) Schema (required vs optional fields, typed)

```ts
export type EpisodeStatus = "active" | "archived";

export type Episode = {
  schema_version: 1;                // REQUIRED

  id: string;                       // REQUIRED (ep_...)
  network_id: string;               // REQUIRED (nw_...)

  scope: Scope;                     // REQUIRED (v0.1: "private")

  title: string;                    // REQUIRED (e.g. "Session 0")
  ordinal?: number;                 // OPTIONAL (recommended; Episode 0 => 0)

  curated_item_ids?: string[];
  curated_bond_ids?: string[];

  status: EpisodeStatus;            // REQUIRED

  started_at: ISO8601;              // REQUIRED
  ended_at?: ISO8601;               // OPTIONAL (required if archived)
  last_active_at: ISO8601;          // REQUIRED

  created_by: "user" | "system";    // REQUIRED
  created_by_actor?: ActorRef;      // OPTIONAL

  created_at: ISO8601;              // REQUIRED
  updated_at: ISO8601;              // REQUIRED
};
```

**REQUIRED fields:** `schema_version, id, network_id, scope, title, status, started_at, last_active_at, created_by, created_at, updated_at`
**OPTIONAL fields:** `ordinal, curated_item_ids, curated_bond_ids, ended_at, created_by_actor`

### C) Invariants / validation rules

* `id` MUST start with `ep_` and be unique.
* `title` MUST be non-empty.
* `status === "archived"` implies `ended_at` is present.
* `started_at <= last_active_at <= updated_at`.
* `ended_at` (if present) MUST be ≥ `started_at`.
* If `curated_item_ids` is present, IDs MUST be unique within the list (no duplicates).
* If `curated_bond_ids` is present, IDs MUST be unique within the list (no duplicates).
* If `curated_item_ids` is present, each referenced Item ID MUST resolve to an Item where:

  * `item.network_id === episode.network_id`
  * `item.episode_id === episode.id`
* If `curated_bond_ids` is present, each referenced Bond ID MUST resolve to a Bond where:

  * `bond.network_id === episode.network_id`
  * `bond.episode_id === episode.id`
* Archived objects are filtered out by the canon projection (Canon Policy); the curated lists themselves are not auto-mutated in v0.1.

### D) Typical lifecycle

* **Created:** Episode 0 is created by system on first launch; later Episodes may be created by user.
* **Updated:** rename title; update `last_active_at`; update optional curation lists.
* **Archived:** set `status:"archived"` and `ended_at`; still queryable.
* **Immutable:** `id`, `network_id`, `started_at` (creation anchors).

### E) Indexing/query keys

* `network_id`
* `status`
* `started_at`, `last_active_at`
* `ordinal` (if used)

### F) Example JSON objects (2)

**Example 1 — Episode 0 (created)**

```json
{
  "schema_version": 1,
  "id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "scope": "private",
  "title": "Session 0",
  "ordinal": 0,
  "status": "active",
  "started_at": "2025-12-16T00:00:02.120Z",
  "last_active_at": "2025-12-16T00:00:02.120Z",
  "created_by": "system",
  "created_by_actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "created_at": "2025-12-16T00:00:02.120Z",
  "updated_at": "2025-12-16T00:00:02.120Z"
}
```

**Example 2 — Episode 0 (after activity; last_active_at advanced)**

```json
{
  "schema_version": 1,
  "id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "scope": "private",
  "title": "Session 0",
  "ordinal": 0,
  "status": "active",
  "started_at": "2025-12-16T00:00:02.120Z",
  "last_active_at": "2025-12-16T00:00:48.210Z",
  "created_by": "system",
  "created_by_actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "created_at": "2025-12-16T00:00:02.120Z",
  "updated_at": "2025-12-16T00:00:48.210Z"
}
```

---

## 6.4) Network

### A) Purpose

A Network is the **top-level workspace** for a Field. It groups Episodes (and thereby Items/Bonds/Events) and carries privacy scope. In v0.1, a single default private Network is required and created at bootstrap.

### B) Schema (required vs optional fields, typed)

```ts
export type Network = {
  schema_version: 1;                // REQUIRED

  id: string;                       // REQUIRED (nw_...)
  scope: Scope;                     // REQUIRED (v0.1: "private")

  title: string;                    // REQUIRED (e.g. "My Field")
  description?: string;             // OPTIONAL

  root_episode_id: string;          // REQUIRED (ep_...; typically Episode 0)
  active_episode_id?: string;       // OPTIONAL (ep_...)

  created_by: "user" | "system";    // REQUIRED
  created_by_actor?: ActorRef;      // OPTIONAL

  created_at: ISO8601;              // REQUIRED
  updated_at: ISO8601;              // REQUIRED
  archived_at?: ISO8601;            // OPTIONAL
};
```

**REQUIRED fields:** `schema_version, id, scope, title, root_episode_id, created_by, created_at, updated_at`
**OPTIONAL fields:** `description, active_episode_id, created_by_actor, archived_at`

### C) Invariants / validation rules

* `id` MUST start with `nw_` and be unique.
* `title` MUST be non-empty.
* `scope` MUST be `"private"` in v0.1 runtime enforcement.
* `root_episode_id` MUST reference an existing Episode whose `network_id` matches this Network.
* If `active_episode_id` is set, it MUST reference an Episode whose `network_id` matches this Network.

### D) Typical lifecycle

* **Created:** required at bootstrap (system creates “My Field”).
* **Updated:** rename title; switch active episode; update `updated_at`.
* **Archived:** optional (rare in v0.1).

### E) Indexing/query keys

* `scope`
* `updated_at`
* `root_episode_id`, `active_episode_id`

### F) Example JSON objects (2)

**Example 1 — Default Network (system-created)**

```json
{
  "schema_version": 1,
  "id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "scope": "private",
  "title": "My Field",
  "description": "Local Blank Field workspace",
  "root_episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "active_episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "created_by": "system",
  "created_by_actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "created_at": "2025-12-16T00:00:02.000Z",
  "updated_at": "2025-12-16T00:00:02.000Z"
}
```

**Example 2 — Updated Network (renamed locally; still private/local)**

```json
{
  "schema_version": 1,
  "id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "scope": "private",
  "title": "Lab Notebook",
  "description": "Local Blank Field workspace",
  "root_episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "active_episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "created_by": "system",
  "created_by_actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "created_at": "2025-12-16T00:00:02.000Z",
  "updated_at": "2025-12-16T00:10:00.000Z"
}
```

---

## 6.5) QDPIEvent

### A) Purpose

QDPIEvent is the **append-only immutable Ledger**. It records user-meaningful actions (create/update/run/open) and key system outcomes (commit success/failure), tagged with QDPI (Q/M/D/H). It enables audit, debugging, and future replay.

### B) Schema (required vs optional fields, typed)

```ts
// direction indicates how the event relates to the local Field store.
// v0.1 core values: "user→field" and "system→field".
// "field→user" is reserved for debug-only UI/render telemetry and MUST set is_debug: true if ever used.
export type EventDirection = "user→field" | "system→field" | "field→user";

export type QDPIEvent = {
  schema_version: 1;                // REQUIRED

  id: string;                       // REQUIRED (ev_...)
  network_id: string;               // REQUIRED (nw_...)
  episode_id: string;               // REQUIRED (ep_...)

  ts: ISO8601;                      // REQUIRED
  seq: number;                      // REQUIRED (monotonic per episode)

  qdpi: QDPI;                       // REQUIRED ("Q" | "M" | "D" | "H")
  direction: EventDirection;        // REQUIRED

  actor: ActorRef;                  // REQUIRED (who initiated / recorded)
  name: string;                     // REQUIRED (dot-separated, stable)

  // Minimal payload, event-specific
  refs: Record<string, unknown>;    // REQUIRED (may be empty object)

  // Debug-only flag for noisy UI/render events (off by default)
  is_debug?: boolean;               // OPTIONAL

  // Optional integrity chaining (future)
  prev_event_id?: string;           // OPTIONAL (ev_...)
};
```

**REQUIRED fields:** `schema_version, id, network_id, episode_id, ts, seq, qdpi, direction, actor, name, refs`
**OPTIONAL fields:** `is_debug, prev_event_id`

### C) Invariants / validation rules

* QDPIEvent is **immutable** once written.
* `id` MUST start with `ev_` and be unique.
* `seq` MUST be unique per `episode_id` and strictly increasing (no gaps required, but recommended).
* `refs` MUST be valid JSON and MUST NOT contain secrets.
* **Corrections are new events:** never edit an event; append a new event that references the prior one via `refs.corrects_event_id` (or similar).
* **Debug-only direction rule (v0.1):** if `direction === "field→user"`, then `is_debug` MUST be `true`.

### D) Typical lifecycle

* **Appends only:** create and append.
* **No updates, no deletes.**
* Filtering is a view concern (e.g., hide `is_debug` by default).

### E) Indexing/query keys

* `(episode_id, seq)` primary ordering
* `network_id`
* `name`
* `qdpi`
* Time windows via `ts`

### F) Example JSON objects (2+)

**Example 1 — First-run started (Queue)**

```json
{
  "schema_version": 1,
  "id": "ev_01JFA3K9A1B2C3D4E5F6G7H8J",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "ts": "2025-12-16T00:00:02.140Z",
  "seq": 1,
  "qdpi": "Q",
  "direction": "system→field",
  "actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "name": "app.first_run.started",
  "refs": {}
}
```

**Example 2 — Bond executed (Monologue) producing an output Item**

```json
{
  "schema_version": 1,
  "id": "ev_01JFA3KS9B1N2B3C4D5E6F7G8H9",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "ts": "2025-12-16T00:00:26.410Z",
  "seq": 9,
  "qdpi": "M",
  "direction": "system→field",
  "actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "name": "bond.executed",
  "refs": {
    "bond_id": "bd_01JFA3KJ7V3J1QZ1R2N0F0G8TT",
    "input_item_ids": ["it_01JFA3KB2Q4P6D4X9H2ZK8N3AA"],
    "output_item_id": "it_01JFA3KS1Q0W4Z8R6M9N2B7C3DD",
    "execution_count": 1
  }
}
```

**Example 3 — Credits delta (Queue; derived bookkeeping)**

```json
{
  "schema_version": 1,
  "id": "ev_01JFA3M0C9R3D1T5D3LTA0001",
  "network_id": "nw_01JFA3K8P2K8R3X3N9V0V6B9TQ",
  "episode_id": "ep_01JFA3K9YQ8D7S2J9R3M2W0X1Z",
  "ts": "2025-12-16T00:00:26.420Z",
  "seq": 10,
  "qdpi": "Q",
  "direction": "system→field",
  "actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "name": "credits.delta",
  "refs": {
    "delta": -10,
    "balance_after": 90,
    "reason": "bond_executed",
    "related": {
      "bond_id": "bd_01JFA3KJ7V3J1QZ1R2N0F0G8TT",
      "qdpi_event_id": "ev_01JFA3KS9B1N2B3C4D5E6F7G8H9"
    }
  }
}
```

## 7) Cross-object Relationships (explicit)

### Relationship rules

* **Items ↔ Bonds**

  * A Bond references input Items by `input_item_ids`.
  * An executed Bond references its latest output Item via `output_item_id`.
  * An output Item created by a Bond MUST include provenance `{ created_by:"bond", bond_id, input_item_ids }`.
* **Episodes ↔ Items/Bonds/QDPIEvents**

  * Items, Bonds, and Events MUST carry `episode_id`.
  * Episode does not store arrays of **all** child IDs in v0.1 (derived views via query), but it MAY store optional curation lists (`curated_item_ids`, `curated_bond_ids`) for canon projection.
* **Networks ↔ Episodes/Items/Bonds/Events**

  * All objects MUST carry `network_id` for simple scoping and queries.
  * A Network’s `root_episode_id` must belong to the same network.
* **QDPIEvents reference everything**

  * Events reference object IDs in `refs` (e.g., `item_id`, `bond_id`, `output_item_id`, `selected_item_ids`).

### Diagram-like flow (v0.1 operator loop)

* `Item(type=Q, created_by=user)`
  → `Bond(status=draft, input_item_ids=[Q], prompt_text=...)`
  → `QDPIEvent(qdpi=Q, name="bond.run_requested")`
  → `QDPIEvent(qdpi=M, name="bond.executed") + Item(type=M or D, created_by=bond, provenance.bond_id=...)`
  → select constellation of `2+ Items` (e.g., Q + output)
  → `QDPIEvent(qdpi=H, name="holologue.completed") + Item(type=H, created_by=holologue, provenance.holologue_event_id=...)`

## 8) Provenance + Lineage Model (minimal, explicit)

### Bond-derived output Item

* **Bond is the single user-facing object** that stores both structural linkage and prompt text.
* When a Bond execution succeeds:

  1. create a new Item with `provenance.created_by:"bond"`, `bond_id`, and `input_item_ids`.
  2. update the Bond to `status:"executed"` and set `output_item_id` to the new Item ID.
  3. append `bond.executed` QDPIEvent referencing `bond_id`, `input_item_ids`, `output_item_id`.

This model avoids conflating **semantic meaning** with provenance: the prompt text is stored on the Bond; provenance records *what generated what*.

### Holologue-derived artifact Item

* Holologue is a Field operation that produces **one specific artifact Item** from a constellation.
* On success:

  1. append `holologue.completed` QDPIEvent with `selected_item_ids`, `output_item_id`, and `artifact_kind`.
  2. create a new Item with `provenance.created_by:"holologue"`, `holologue_event_id`, `selected_item_ids`, and `artifact_kind`.

## 9) Event Sourcing Rules (explicit)

### Core rules

* **QDPIEvent is append-only and immutable.**
* Any correction to a prior event is represented by a **new** event (e.g., `refs.corrects_event_id`).
* Object state (Item/Bond/Episode/Network) is stored as mutable snapshots, but **events are the canonical audit trail**.

### What SHOULD be logged as QDPIEvents in v0.1

* **State-changing operations:**

  * `episode.created`, `item.created`, `item.updated`, `bond.draft_created`, `bond.updated` (draft), `bond.executed`, `holologue.completed`
* **Operator requests and failures:**

  * `bond.run_requested` (**qdpi:"Q"**), `bond.execution_failed`
  * `holologue.run_requested` (**qdpi:"H"**), `holologue.failed`, `holologue.validation_failed`
* **Credits bookkeeping (simulation; derived from events):**

  * `credits.delta` (**qdpi:"Q"**, **direction:"system→field"** recommended)
* **Key inspections:**

  * `ledger.opened` (**qdpi:"Q"**)
* **Persistence outcomes:**

  * `store.commit`, `store.commit_failed` (**qdpi:"Q"**)
* **NOT logged by default:** pure render/paint/layout events; those are debug-only with `is_debug: true`. In v0.1, direction `field→user` render/paint/layout events are NOT logged by default; if captured at all, they MUST be marked `is_debug: true`.

### Example event names (aligned with first-run)

* `app.first_run.started`
* `episode.created`
* `item.created`
* `bond.draft_created`
* `bond.run_requested`
* `bond.executed`
* `holologue.completed`
* `credits.delta`
* `ledger.opened`
* `store.commit`
* `store.commit_failed`

## 10) Minimal Storage Mapping (MVP)

### JSONL mapping (recommended bootstrap floor)

Store each object type in its own JSONL file; each line is a full object snapshot.

* `items.jsonl` (append snapshots; latest `updated_at` wins per `id`)
* `bonds.jsonl` (append snapshots; latest `updated_at` wins per `id`)
* `episodes.jsonl` (append snapshots; latest `updated_at` wins per `id`)
* `networks.jsonl` (append snapshots; latest `updated_at` wins per `id`)
* `qdpi_events.jsonl` (**append-only**, immutable)

**Load strategy (v0.1):**

* For Items/Bonds/Episodes/Networks: replay file in order and keep the last snapshot per `id`.
* For QDPIEvents: replay file in order; maintain `(episode_id, seq)` ordering; never overwrite.

**Denormalized fields we store on purpose (v0.1):**

* `episode_id` and `network_id` on Item, Bond, QDPIEvent
* `input_item_ids` and `output_item_id` on Bond
* `provenance` on Item

### SQLite mapping (optional, recommended after bootstrap)

High-level tables (store arrays as JSON text in v0.1; normalize later if needed):

* `networks(id TEXT PRIMARY KEY, scope TEXT, title TEXT, description TEXT, root_episode_id TEXT, active_episode_id TEXT, created_by TEXT, created_at TEXT, updated_at TEXT, archived_at TEXT, schema_version INTEGER)`
* `episodes(id TEXT PRIMARY KEY, network_id TEXT, scope TEXT, title TEXT, ordinal INTEGER, curated_item_ids_json TEXT, curated_bond_ids_json TEXT, status TEXT, started_at TEXT, ended_at TEXT, last_active_at TEXT, created_by TEXT, created_at TEXT, updated_at TEXT, schema_version INTEGER)`
* `items(id TEXT PRIMARY KEY, network_id TEXT, episode_id TEXT, scope TEXT, type TEXT, title TEXT, body TEXT, position_json TEXT, provenance_json TEXT, created_at TEXT, updated_at TEXT, archived_at TEXT, schema_version INTEGER)`
* `bonds(id TEXT PRIMARY KEY, network_id TEXT, episode_id TEXT, scope TEXT, input_item_ids_json TEXT, prompt_text TEXT, status TEXT, output_item_id TEXT, intent_type TEXT, executed_at TEXT, execution_count INTEGER, last_error_json TEXT, created_by TEXT, created_at TEXT, updated_at TEXT, archived_at TEXT, schema_version INTEGER)`
* `qdpi_events(id TEXT PRIMARY KEY, network_id TEXT, episode_id TEXT, ts TEXT, seq INTEGER, qdpi TEXT, direction TEXT, actor_json TEXT, name TEXT, refs_json TEXT, is_debug INTEGER, prev_event_id TEXT, schema_version INTEGER)`

Recommended indexes:

* `qdpi_events(episode_id, seq)` UNIQUE
* `items(network_id, episode_id, type)`
* `bonds(network_id, episode_id, status)`
* `bonds(output_item_id)`
* `episodes(network_id, status, started_at)`

## 11) Versioning + Migration Strategy

* Every object includes `schema_version: 1` in v0.1.
* **Forward-compatible additions:** new optional fields may be added without migration.
* **Enum evolution:** prefer adding new enum values (and handling unknowns) rather than renaming.
* **Breaking changes:** require a migration step that rewrites snapshots (JSONL) or runs a SQL migration (SQLite).
* **Deprecation policy:** keep deprecated fields readable for at least 2 minor schema revisions; stop writing them after one revision.

## 12) Security/Privacy Notes (minimal)

* Default and enforced runtime scope in v0.1: **`private` + local-only**.
* No cross-user identifiers are required in v0.1; `ActorRef.id` may be `"local-user"` and `"system"`.
* Shared/public scopes exist in schema for forward compatibility, but v0.1 must not export or expose data externally.

## 13) Definition of Done (checklist)

* [ ] TypeScript schemas compile and are used consistently across the codebase.
* [ ] IDs follow required prefixes and are unique: `ep_`, `it_`, `bd_`, `nw_`, `ev_`.
* [ ] Episode 0 is auto-created on first launch and stored as an Episode snapshot.
* [ ] Items support provenance:

  * [ ] `created_by` is one of `"user" | "system" | "bond" | "holologue"`.
  * [ ] Bond outputs include `bond_id` and `input_item_ids`.
  * [ ] Holologue artifacts include `holologue_event_id`, `selected_item_ids`, and `artifact_kind`.
* [ ] Bonds are prompt + connector in one object:

  * [ ] `input_item_ids` and `prompt_text` are required.
  * [ ] Lifecycle exists: `draft → executed`.
  * [ ] When executed, `output_item_id` is non-null and references an Item.
  * [ ] Failure representation is implemented: keep `status:"draft"` and set `last_error`.
* [ ] QDPIEvent is append-only and immutable:

  * [ ] Events are ordered by `(episode_id, seq)`.
  * [ ] Corrections are new events; events are never edited.
  * [ ] `direction` is used (not `flow`) and defaults to `user→field` / `system→field` in v0.1.
  * [ ] v0.1 logs state-changing ops + key inspections + store outcomes; render/paint/layout events are debug-only.
* [ ] Credits simulation is event-derived (no new core object):

  * [ ] `credits.delta` QDPIEvents record `delta`, `balance_after`, `reason` (and optional `related` refs).
  * [ ] Credits balance is computed as a derived view from events.
* [ ] Minimal storage mapping works:

  * [ ] JSONL files exist: `items.jsonl`, `bonds.jsonl`, `episodes.jsonl`, `networks.jsonl`, `qdpi_events.jsonl`.
  * [ ] Loader reconstructs current state from snapshots and event log reliably.

## 14) Open Questions (5–12)

1. Should we later add `BondStatus = "failed"` instead of (or in addition to) `draft + last_error` for clearer UX and analytics?
2. Should executed Bonds be strictly read-only forever, or should we allow edits that automatically fork a new Bond (preserving lineage)?
3. Should QDPIEvent logging ever include UI/render events in production (not just debug), and if so, what is the minimum safe subset?
4. Should Holologue bond proposals be recorded as **events only** (v0.1 default) or also materialize as draft Bonds with `created_by:"system"`?
5. Do we want an explicit `holologue_run_id` separate from `holologue_event_id`, or is “completed event ID == run ID” sufficient for v0.1?
6. Should Item `type` remain limited to `"Q" | "M" | "D" | "H"` in v0.1, or do we need an escape hatch like `"X"` for custom roles?
7. How should we represent multi-select constellations that include Bonds (not just Items) if Holologue later supports “Items + Bonds” as inputs?
8. Should we ever support an implicit default Network in the future, or must Network always be explicit and required?
9. What minimal integrity guarantees do we want for the event log (e.g., `prev_event_id` chaining, hashing) in local-only v0.1?
10. Should `Scope` be enforced per object (Item/Bond/Episode/Network) or derived from `Network.scope` to avoid inconsistent states?
11. For Credits (simulation), do we want a recommended seed default (e.g., `credits.delta` with `reason:"seed"`) as part of bootstrap, or should seed be purely a product-layer choice?