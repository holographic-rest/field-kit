# Spin Recipes v0.1

## 1) Front Matter

* **Title:** Spin Recipes v0.1
* **Version:** v0.1
* **Date:** 2025-12-16
* **Status:** Draft
* **Suggested repo path:** `/docs/specs/07_spin_recipes_v0.1.md`

## 2) Purpose

Spin Recipes are a small, reusable library of **copy/paste-ready prompt templates** that Field-Kit can use to (a) suggest Bond prompts for **Q→M** (system-suggested Bond execution), (b) support **Q→D** (user-written Bond execution), (c) drive **Holologue** runs (many→one artifact creation), and (d) generate **proposal sets** (4 bond prompt suggestions as events only). Recipes exist to improve **repeatability, output quality, and diversity** while preserving the core rule: **the Bond’s `prompt_text` is primary and editable; recipes are defaults, not constraints.**

### Terms (v0.1)

* **Episode:** A local, user-owned container for one working session. Every persisted object and every QDPIEvent belongs to exactly one Episode via `episode_id`.
* **Item:** A persistent node of content in the Field, created by a user or generated by an operator. Items are addressable by ID and include a `type` (e.g., `Q`, `M`, `D`, `H`) plus content and minimal metadata.
* **Bond:** A persistent instruction that connects one or more input Items to an operator run. `prompt_text` is the primary instruction. Bonds are created as `status:"draft"` and may be executed; execution generates exactly one output Item and MUST set `status:"executed"` and `output_item_id`.
* **QDPIEvent:** An append-only event record that logs meaningful actions and results. Each event includes `qdpi` (Queue/Monologue/Dialogue/Holologue), `direction` (user→field or system→field), a `name`, a timestamp, and refs to related object IDs.
* **Proposal:** A system suggestion (e.g., suggested Bond prompts) that is logged as events only until the user explicitly confirms creation.
* **Canon:** A user-curated projection over Items/Bonds within an Episode used for presentation or replay. Canon never overrides the append-only event log.
* **Bundle:** A structured artifact output of a Holologue run (many→one) capturing what was selected, what was generated, and any optional proposals. A Bundle may be represented as a single output Item plus an exportable JSON payload.

## 3) Scope and Non-goals (v0.1)

* v0.1 is **Private • Local**: no accounts, no cloud sync, no collaboration, no publishing.
* Spin Recipes are a **local library of prompt templates**; they do **not** introduce payments/crypto.
* Recipes are **defaults**; the user can always edit `Bond.prompt_text` before creating a Bond draft or running a Bond.

## 4) Global Rules (v0.1)

**Prompt-first**

* A Bond is the prompt: `Bond.prompt_text` is user-facing and primary.
* `intent_type` is optional/secondary and must never be required for execution.

**Bond lifecycle invariant (v0.1)**

* Draft Bond: `status:"draft"`, `output_item_id:null`
* Executed Bond: `status:"executed"`, `output_item_id` set
  (Failures remain draft with `last_error` per the suite; no third Bond status is introduced here.)

**Content-shaped requirement**

* Every recipe MUST incorporate at least one **anchor phrase** from the input Item(s) (a key noun/phrase from title/body).
* The anchor phrase MUST appear verbatim in the rendered prompt (quoted or otherwise clearly included).

**Specificity requirement**

* Outputs MUST be concrete and structured (checklists, steps, claims with tests, schemas with invariants, etc.).
* Recipes MUST include structure markers in the output contract (headings, bullets, numbered steps, etc.).
* Avoid generic “here are some thoughts” outputs.

**Multi-purpose**

* Neutral tone by default (engineering/scientific/clear writing).
* Optional **style lenses** may be offered explicitly (e.g., `{{style_lens}} = "skeptical" | "creative" | "terse" | "verbose"`), but **off by default** and never hardcoded.

**Safety/privacy**

* Do not extract or infer private data beyond what is present in the input Items.
* Do not fabricate user secrets. If information is missing, the output should use placeholders or ask for clarifying inputs as explicit TODOs.

**Proposals are events-only**

* Suggested prompts appear as QDPIEvents (`bond.suggestions.presented` / `bond.proposals.presented`) until the user confirms by creating a Bond draft.

**Logging (v0.1)**

* Logging is via append-only **QDPIEvents**.
* Use `direction` values `user→field` and `system→field` (do not use `flow`).
* Log **state-changing operations** and **key inspections** only (e.g., Ledger opened).
* Do **not** log render/paint/layout events by default; if captured at all, they MUST be debug-only.

### Credits hooks (v0.1 simulation)

Credits are an optional, local-only simulation layer that can be used to meter operator runs in a way that is inspectable in the Ledger, without implying money.

* Credits are **local-only** and **purely simulated** in v0.1.
* Credits are **not transferable**, **not redeemable**, and have **no USD exchange rate** in v0.1.
* Credits are represented as **append-only QDPIEvents** named `credits.delta`; balance is a **derived view** (no new required core object).

**Credits event shape (standard pattern, v0.1):**

* Event name: `credits.delta`
* `qdpi:"Q"`, `direction:"system→field"`
* `refs` includes:

  * `delta` (int)
  * `balance_after` (int)
  * `reason` (string)
  * optional related IDs: `bond_id`, `output_item_id`, `holologue_event_id`

**Minimal JSON example (credits.delta QDPIEvent):**

```json
{
  "schema_version": 1,
  "id": "ev_01JFSPIN01EV000000000000001",
  "network_id": "nw_01JFSPIN01NET00000000000001",
  "episode_id": "ep_01JFSPIN01EP000000000000001",
  "ts": "2025-12-16T00:06:00.000Z",
  "seq": 12,
  "qdpi": "Q",
  "direction": "system→field",
  "actor": { "kind": "system", "id": "system", "display": "Field-Kit" },
  "name": "credits.delta",
  "refs": {
    "delta": -10,
    "balance_after": 90,
    "reason": "bond_run_spend",
    "bond_id": "bd_01JFSPIN01BOND00000000000001"
  }
}
```

Notes:

* A metered run may emit **one or more** `credits.delta` events (e.g., spend then reward/refund). In this document’s recipe lists, `credits.delta` appears once to indicate it is part of the typical event trail for that move.

## 5) Recipe Template Schema

### Canonical template structure (Markdown)

Each recipe below follows this exact template:

* **Name / ID:** `snake_case`
* **Intended move:** `Q→M` / `Q→D` / `many→one H` / `proposals`
* **Inputs (required):** fields required to render the prompt
* **Output contract:** what the produced Item or proposal set must look like (structure markers)
* **Constraints:** length, formatting, specificity rules
* **Logging expectations (names only):** event names typically accompanying this recipe (may include `credits.delta` for metered runs)
* **Prompt template:** copy/paste-ready template with placeholders
* **Example instantiation:** same template with placeholders filled

### Storage-oriented schema (JSON-ish)

Engineers can store recipes as data records. (This is a storage suggestion, not a new object type.)

```json
{
  "id": "implementation_plan",
  "version": "v0.1",
  "move": "Q→M",
  "inputs_required": ["item_title", "item_body", "anchor_phrase"],
  "inputs_optional": ["style_lens"],
  "output_contract": {
    "output_item_type": "M",
    "required_markers": ["Plan:", "Steps:", "Risks:", "Next:"]
  },
  "constraints": {
    "max_words": 220,
    "min_markers": 4
  },
  "logging_expectations": [
    "bond.suggestions.presented",
    "bond.draft_created",
    "bond.run_requested",
    "credits.delta",
    "bond.executed",
    "store.commit"
  ],
  "template": "…string with {{placeholders}}…"
}
```

### Placeholder definitions (v0.1)

* `{{item_title}}` — full input Item title
* `{{item_body}}` — full input Item body (may be truncated for prompt rendering)
* `{{anchor_phrase}}` — a noun/phrase extracted from the Item (must appear verbatim in prompt)
* `{{selected_items}}` — newline list of selected items, each as `- {{title}}: {{body_snippet}}`
* `{{artifact_kind}}` — holologue artifact kind (preset or custom)
* `{{artifact_target_text}}` — optional user target (“what do you want to produce?”)
* `{{style_lens}}` — optional explicit style lens (default empty / omitted)

## 6) Monologue Recipes (Q→M) — 8

> These are designed for **system-suggested** Bond prompts (presented as events only) that, when executed, generate a single-voice **Item type "M"**.

---

### Recipe 1: `clarify_to_testable_claim`

* **Name / ID:** `clarify_to_testable_claim`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST include headings:

  * `Claim:` (1 sentence)
  * `Operational definition:` (1–3 bullets)
  * `Test:` (2–4 steps)
  * `Success criteria:` (2 bullets)
  * `Next action:` (1 bullet)
* **Constraints:** 120–220 words; include `{{anchor_phrase}}`; avoid generic advice.
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Using the Item titled "{{item_title}}" (anchor: "{{anchor_phrase}}"), rewrite the idea into a testable claim.
  Output format MUST be exactly:

  Claim:
  Operational definition:
  Test:
  Success criteria:
  Next action:

  Use only information grounded in the Item body below; if a detail is missing, write a TODO bullet.
  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Using the Item titled "My First Field Item" (anchor: "prove persistence"), rewrite the idea into a testable claim.
  Output format MUST be exactly:

  Claim:
  Operational definition:
  Test:
  Success criteria:
  Next action:

  Use only information grounded in the Item body below; if a detail is missing, write a TODO bullet.
  Item body:
  I want onboarding to prove this isn't chat by showing saved objects and a ledger trail.
  ```

---

### Recipe 2: `expand_to_checklist`

* **Name / ID:** `expand_to_checklist`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST contain:

  * `Checklist:` with **≥ 8** checkbox lines `- [ ] ...`
  * `Definition of done:` with **3** bullets
* **Constraints:** 8–14 checklist items; each checklist line must be specific; include `{{anchor_phrase}}`.
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Turn "{{item_title}}" into a practical checklist focused on "{{anchor_phrase}}".
  Requirements:
  - Output MUST start with "Checklist:" and include at least 8 checkbox lines using "- [ ]".
  - Include a final section "Definition of done:" with exactly 3 bullets.
  - Avoid generic items like "think about" or "consider".
  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Turn "Holologue step quality" into a practical checklist focused on "not summary-by-default".
  Requirements:
  - Output MUST start with "Checklist:" and include at least 8 checkbox lines using "- [ ]".
  - Include a final section "Definition of done:" with exactly 3 bullets.
  - Avoid generic items like "think about" or "consider".
  Item body:
  Holologue outputs must be concrete artifacts with structure and novelty.
  ```

---

### Recipe 3: `ground_in_experiment`

* **Name / ID:** `ground_in_experiment`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST include:

  * `Hypothesis:` (1 sentence)
  * `Method:` (3–6 bullets)
  * `Metric:` (2 metrics)
  * `Stop rule:` (1 sentence)
  * `Controls:` (2 bullets)
* **Constraints:** ≤ 240 words; include `{{anchor_phrase}}`; must be runnable without external data.
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Convert the Item into a small experiment plan about "{{anchor_phrase}}".
  Use headings exactly: Hypothesis, Method, Metric, Stop rule, Controls.
  Keep it runnable locally and grounded in the Item content (no invented external facts).
  Item title: {{item_title}}
  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Convert the Item into a small experiment plan about "time to first bond execution".
  Use headings exactly: Hypothesis, Method, Metric, Stop rule, Controls.
  Keep it runnable locally and grounded in the Item content (no invented external facts).
  Item title: Demo success metrics
  Item body:
  We want the guided tutorial to reach bond execution quickly and reliably.
  ```

---

### Recipe 4: `derive_min_schema`

* **Name / ID:** `derive_min_schema`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST include:

  * `Entities:` (list 2–5)
  * `Fields:` (per entity, 3–7 fields)
  * `Invariants:` (≥ 5, each starts with `- MUST`)
  * `Queries:` (≥ 3)
* **Constraints:** 180–260 words; include `{{anchor_phrase}}`; avoid adding new object types beyond the five core objects unless marked as “future”.
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  From "{{item_title}}" (anchor: "{{anchor_phrase}}"), derive a minimal schema sketch.
  Output sections MUST be: Entities, Fields, Invariants, Queries.
  Use "MUST" language for invariants. Do not invent new core object types.
  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  From "Canon Policy rules" (anchor: "curated view"), derive a minimal schema sketch.
  Output sections MUST be: Entities, Fields, Invariants, Queries.
  Use "MUST" language for invariants. Do not invent new core object types.
  Item body:
  Canon is derived from curated lists on the Episode and archived objects are filtered out.
  ```

---

### Recipe 5: `decision_with_reasons`

* **Name / ID:** `decision_with_reasons`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST include:

  * `Decision:` (one sentence starting with “We will…”)
  * `Rationale:` (3 bullets)
  * `Tradeoffs:` (2 bullets)
  * `Risks:` (2 bullets)
  * `Next:` (2 bullets)
* **Constraints:** ≤ 220 words; include `{{anchor_phrase}}`; must contain at least one explicit constraint (“MUST/SHOULD”).
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Turn the Item into a crisp decision record about "{{anchor_phrase}}".
  Required format:
  Decision:
  Rationale:
  Tradeoffs:
  Risks:
  Next:

  Include at least one MUST/SHOULD constraint grounded in the Item.
  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Turn the Item into a crisp decision record about "log state changes only".
  Required format:
  Decision:
  Rationale:
  Tradeoffs:
  Risks:
  Next:

  Include at least one MUST/SHOULD constraint grounded in the Item.
  Item body:
  In v0.1 we log state-changing operations and key inspections; render events are debug-only.
  ```

---

### Recipe 6: `compare_with_criteria`

* **Name / ID:** `compare_with_criteria`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST include:

  * `Options:` (exactly 2 options)
  * `Criteria:` (≥ 5 criteria bullets)
  * `Comparison table:` (markdown table with rows = criteria)
  * `Recommendation:` (1–2 sentences)
* **Constraints:** Table must be valid markdown; include `{{anchor_phrase}}`; no third option.
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Compare two viable options related to "{{anchor_phrase}}" based on the Item.
  Output MUST include sections: Options, Criteria, Comparison table, Recommendation.
  In the table, score each option as Low/Med/High per criterion.
  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Compare two viable options related to "curated list validity" based on the Item.
  Output MUST include sections: Options, Criteria, Comparison table, Recommendation.
  In the table, score each option as Low/Med/High per criterion.
  Item body:
  Curated IDs must be unique, valid, same episode/network, archived filtered with warnings.
  ```

---

### Recipe 7: `risk_register`

* **Name / ID:** `risk_register`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST include:

  * `Risk register:` markdown table with columns: `Risk | Trigger | Impact | Mitigation | Owner`
  * At least **6** rows
* **Constraints:** Each mitigation must be actionable; include `{{anchor_phrase}}` in at least one risk row.
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Create a risk register for "{{item_title}}" focusing on "{{anchor_phrase}}".
  Output MUST be a markdown table with columns: Risk | Trigger | Impact | Mitigation | Owner
  Include at least 6 rows. Use only risks grounded in the Item content.
  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Create a risk register for "Demo Golden Flow" focusing on "ledger verification".
  Output MUST be a markdown table with columns: Risk | Trigger | Impact | Mitigation | Owner
  Include at least 6 rows. Use only risks grounded in the Item content.
  Item body:
  Demo depends on stable IDs, event ordering, and showing lineage in the ledger.
  ```

---

### Recipe 8: `implementation_plan`

* **Name / ID:** `implementation_plan`
* **Intended move:** Q→M
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (M) MUST include:

  * `Plan:` (1 sentence)
  * `Steps:` numbered list with **6–10** steps
  * `Data writes:` list of objects/events written (≥ 5 bullets)
  * `Checks:` list of acceptance checks (≥ 5 bullets)
* **Constraints:** Steps must reference concrete operations (create Item, create Bond draft, run Bond, log event, etc.); include `{{anchor_phrase}}`.
* **Logging expectations (names only):** `bond.suggestions.presented`, `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Produce an implementation plan for "{{anchor_phrase}}" based on:
  Title: {{item_title}}
  Body:
  {{item_body}}

  Output format MUST include: Plan, Steps (numbered), Data writes, Checks.
  Keep it concrete (objects + events), not narrative.
  ```
* **Example instantiation:**

  ```text
  Produce an implementation plan for "bond draft→executed lifecycle" based on:
  Title: Bond lifecycle rules
  Body:
  Bonds are prompts+connectors; status draft→executed; executed bonds require output_item_id.

  Output format MUST include: Plan, Steps (numbered), Data writes, Checks.
  Keep it concrete (objects + events), not narrative.
  ```

## 7) Dialogue Recipes (Q→D) — 6

> These are templates for **user-written/co-authored** Bond prompts that typically produce a structured **Item type "D"** (dialogue-shaped artifact). Users can paste these into `Bond.prompt_text` and edit freely.

---

### Recipe 1: `peer_review_objections`

* **Name / ID:** `peer_review_objections`
* **Intended move:** Q→D
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (D) MUST include:

  * `Reviewer objections:` at least **5** bullets
  * `Author replies:` at least **5** bullets (paired to objections)
  * `Actionable changes:` at least **3** bullets
* **Constraints:** Objections must be concrete (testability, clarity, edge cases); include `{{anchor_phrase}}`.
* **Logging expectations (names only):** `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Peer-review the Item titled "{{item_title}}" focusing on "{{anchor_phrase}}".
  Output MUST include:
  Reviewer objections: (>=5 bullets)
  Author replies: (>=5 bullets, matching)
  Actionable changes: (>=3 bullets)

  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Peer-review the Item titled "Holologue quality gate" focusing on "not summary-by-default".
  Output MUST include:
  Reviewer objections: (>=5 bullets)
  Author replies: (>=5 bullets, matching)
  Actionable changes: (>=3 bullets)

  Item body:
  Add structure heuristics and fail with quality_gate_failed after one regeneration attempt.
  ```

---

### Recipe 2: `debate_two_options`

* **Name / ID:** `debate_two_options`
* **Intended move:** Q→D
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (D) MUST include:

  * `Option A:` (2–4 bullets)
  * `Option B:` (2–4 bullets)
  * `Cross-examination:` at least **6** Q/A lines (role-tagged)
  * `Resolution:` one decision sentence + 2 follow-ups
* **Constraints:** Must use the anchor phrase; no third option; keep it technical.
* **Logging expectations (names only):** `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Debate two concrete options related to "{{anchor_phrase}}" using the Item as context.
  Format:
  Option A:
  Option B:
  Cross-examination: (>=6 Q/A lines, tag each line as A: or B:)
  Resolution:

  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Debate two concrete options related to "curated list ordering" using the Item as context.
  Format:
  Option A:
  Option B:
  Cross-examination: (>=6 Q/A lines, tag each line as A: or B:)
  Resolution:

  Item body:
  Curated lists are ordered arrays and order is the presentation order.
  ```

---

### Recipe 3: `refine_prompt_with_constraints`

* **Name / ID:** `refine_prompt_with_constraints`
* **Intended move:** Q→D
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (D) MUST include:

  * `Refined prompt:` (one paragraph the user could paste as a Bond prompt)
  * `Constraints:` at least **6** bullets (structure + length + grounding)
  * `Failure modes:` at least **3** bullets
* **Constraints:** Must include the anchor phrase in the refined prompt; avoid “be helpful”.
* **Logging expectations (names only):** `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Rewrite the intent into a strong, executable prompt that enforces "{{anchor_phrase}}".
  Output:
  Refined prompt:
  Constraints: (>=6 bullets)
  Failure modes: (>=3 bullets)

  Source Item:
  {{item_title}}
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Rewrite the intent into a strong, executable prompt that enforces "append-only events".
  Output:
  Refined prompt:
  Constraints: (>=6 bullets)
  Failure modes: (>=3 bullets)

  Source Item:
  Core Data Objects
  QDPIEvents are append-only and immutable; corrections are new events.
  ```

---

### Recipe 4: `adversarial_test_cases`

* **Name / ID:** `adversarial_test_cases`
* **Intended move:** Q→D
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (D) MUST include:

  * `Test cases:` at least **8** entries, each with `Case:`, `Input:`, `Expected:`, `Why:`
* **Constraints:** Must remain safe (no jailbreak/security bypass prompts); include `{{anchor_phrase}}` in at least two cases.
* **Logging expectations (names only):** `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Generate adversarial-but-safe test cases for "{{item_title}}" focused on "{{anchor_phrase}}".
  Output "Test cases:" with >=8 entries.
  Each entry MUST have: Case, Input, Expected, Why.

  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Generate adversarial-but-safe test cases for "Holologue event ordering" focused on "commit_failed".
  Output "Test cases:" with >=8 entries.
  Each entry MUST have: Case, Input, Expected, Why.

  Item body:
  holologue.completed must only be logged after output item persisted; otherwise holologue.failed(commit_failed).
  ```

---

### Recipe 5: `rubric_and_scoring`

* **Name / ID:** `rubric_and_scoring`
* **Intended move:** Q→D
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (D) MUST include:

  * `Rubric:` markdown table with columns `Criterion | 0 | 1 | 2 | Notes`
  * At least **6** criteria
  * `Scoring guide:` 3 bullets
* **Constraints:** Criteria must be measurable; include `{{anchor_phrase}}` as a criterion.
* **Logging expectations (names only):** `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Create a scoring rubric for "{{anchor_phrase}}" based on the Item.
  Output MUST include a markdown table: Criterion | 0 | 1 | 2 | Notes
  Include at least 6 criteria and a short Scoring guide.

  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Create a scoring rubric for "not summary-by-default" based on the Item.
  Output MUST include a markdown table: Criterion | 0 | 1 | 2 | Notes
  Include at least 6 criteria and a short Scoring guide.

  Item body:
  Holologue artifacts must be concrete, novel, and grounded in multiple inputs.
  ```

---

### Recipe 6: `multi_role_negotiation`

* **Name / ID:** `multi_role_negotiation`
* **Intended move:** Q→D
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Produced Item (D) MUST include:

  * `Roles:` list exactly 3 roles (e.g., PM, Engineer, Researcher)
  * `Negotiation:` at least **12** lines with role tags
  * `Agreed outcome:` 3 bullets
* **Constraints:** Keep roles professional and grounded; include `{{anchor_phrase}}`.
* **Logging expectations (names only):** `bond.draft_created`, `bond.run_requested`, `credits.delta`, `bond.executed`, `store.commit`
* **Prompt template:**

  ```text
  Simulate a 3-role negotiation about "{{anchor_phrase}}" using the Item as context.
  Roles MUST be: Product, Engineering, Research.
  Output:
  Roles:
  Negotiation: (>=12 lines, tag each line)
  Agreed outcome: (3 bullets)

  Item body:
  {{item_body}}
  ```
* **Example instantiation:**

  ```text
  Simulate a 3-role negotiation about "logging only state changes" using the Item as context.
  Roles MUST be: Product, Engineering, Research.
  Output:
  Roles:
  Negotiation: (>=12 lines, tag each line)
  Agreed outcome: (3 bullets)

  Item body:
  Render/paint/layout events are debug-only; ledger is key inspection.
  ```

## 8) Holologue Recipes (many→one) — 6

> Holologue recipes are templates for `artifact_target_text` (and implied structure) for a **many→one** run producing one **Item type "H"**. Each recipe MUST enforce: **not summary-by-default**, **adds a new usable structure**, and includes a quality-gate style instruction (“must contain structure markers and at least one new decision/claim/structure not present verbatim”).

---

### Recipe 1: `holologue_plan_from_constellation`

* **Name / ID:** `holologue_plan_from_constellation`
* **Intended move:** many→one H (instantiate)
* **Inputs (required):** `selected_items`, `anchor_phrase`, `artifact_kind="plan"`
* **Output contract:** Output Item (H) MUST include:

  * `Plan:` (1 sentence)
  * `Steps:` numbered list with **≥ 7** steps
  * `Acceptance checks:` **≥ 5** bullets
  * `Trace:` list of selected item titles (IDs optional)
* **Constraints:** Must mention `{{anchor_phrase}}`; must not recap each input; must introduce at least one new decision/structure.
* **Logging expectations (names only):** `holologue.run_requested`, `credits.delta`, `holologue.completed`, `bond.proposals.presented`, `store.commit`
* **Prompt template:**

  ```text
  From the selected items (anchor: "{{anchor_phrase}}"), produce ONE concrete plan artifact.
  Not summary-by-default: do NOT recap each input. Create a new usable structure.
  Output format MUST be:

  Plan:
  Steps: (>=7 numbered)
  Acceptance checks: (>=5 bullets)
  Trace: (list selected item titles)

  Quality gate: the Steps section must be actionable, and at least one Acceptance check must contain a measurable condition.
  Selected items:
  {{selected_items}}
  ```
* **Example instantiation:**

  ```text
  From the selected items (anchor: "ledger verification"), produce ONE concrete plan artifact.
  Not summary-by-default: do NOT recap each input. Create a new usable structure.
  Output format MUST be:

  Plan:
  Steps: (>=7 numbered)
  Acceptance checks: (>=5 bullets)
  Trace: (list selected item titles)

  Quality gate: the Steps section must be actionable, and at least one Acceptance check must contain a measurable condition.
  Selected items:
  - Demo Golden Flow: Show Q→M, Q→D, Holologue, then Ledger checks.
  - Event Ordering Rules: holologue.completed only after output item persisted.
  ```

---

### Recipe 2: `holologue_spec_fragment_rules`

* **Name / ID:** `holologue_spec_fragment_rules`
* **Intended move:** many→one H (instantiate/generalize hybrid)
* **Inputs (required):** `selected_items`, `anchor_phrase`, `artifact_kind="spec_fragment"`
* **Output contract:** Output Item (H) MUST include:

  * `Rules:` at least **8** lines starting with `- MUST` or `- MUST NOT`
  * `Rationale:` 3 bullets
  * `Test checklist:` at least **6** checkbox lines
* **Constraints:** Must include anchor phrase; rules must be enforceable; no vague “should be good”.
* **Logging expectations (names only):** `holologue.run_requested`, `credits.delta`, `holologue.completed`, `bond.proposals.presented`, `store.commit`
* **Prompt template:**

  ```text
  Produce ONE spec fragment that operationalizes "{{anchor_phrase}}" from the selected items.
  Not summary-by-default: generate new enforceable rules.
  Output MUST include:
  Rules: (>=8 lines with MUST/MUST NOT)
  Rationale: (3 bullets)
  Test checklist: (>=6 checkbox lines)

  Quality gate: at least 3 rules must mention specific objects/events (Item/Bond/QDPIEvent/Episode/Network).
  Selected items:
  {{selected_items}}
  ```
* **Example instantiation:**

  ```text
  Produce ONE spec fragment that operationalizes "append-only audit trail" from the selected items.
  Not summary-by-default: generate new enforceable rules.
  Output MUST include:
  Rules: (>=8 lines with MUST/MUST NOT)
  Rationale: (3 bullets)
  Test checklist: (>=6 checkbox lines)

  Quality gate: at least 3 rules must mention specific objects/events (Item/Bond/QDPIEvent/Episode/Network).
  Selected items:
  - Core Data Objects: QDPIEvents are immutable; corrections are new events.
  - Demo Golden Flow: Ledger must show ordered events by (episode_id, seq).
  ```

---

### Recipe 3: `holologue_taxonomy_or_model`

* **Name / ID:** `holologue_taxonomy_or_model`
* **Intended move:** many→one H (generalize)
* **Inputs (required):** `selected_items`, `anchor_phrase`, `artifact_kind` (custom allowed)
* **Output contract:** Output Item (H) MUST include:

  * `Model:` 3–6 bullet principles
  * `Taxonomy:` 3–5 categories with 1–2 examples each
  * `Predictions:` 3 bullets (“If X then Y”)
* **Constraints:** Must incorporate anchor phrase; must add a new organizing structure; avoid rewriting inputs.
* **Logging expectations (names only):** `holologue.run_requested`, `credits.delta`, `holologue.completed`, `bond.proposals.presented`, `store.commit`
* **Prompt template:**

  ```text
  Build ONE general model/taxonomy from the selected items focused on "{{anchor_phrase}}".
  Not summary-by-default: do not paraphrase each input; synthesize a new organizing structure.
  Output MUST include: Model, Taxonomy, Predictions.

  Quality gate: Predictions must be testable within the app (events/objects/flows), not abstract philosophy.
  Selected items:
  {{selected_items}}
  ```
* **Example instantiation:**

  ```text
  Build ONE general model/taxonomy from the selected items focused on "user confirmation governs persistence".
  Not summary-by-default: do not paraphrase each input; synthesize a new organizing structure.
  Output MUST include: Model, Taxonomy, Predictions.

  Quality gate: Predictions must be testable within the app (events/objects/flows), not abstract philosophy.
  Selected items:
  - Bond Ontology: proposals are events only until user confirms.
  - First-Run Tutorial: user selects a suggestion then creates a draft bond.
  ```

---

### Recipe 4: `holologue_acceptance_checklist`

* **Name / ID:** `holologue_acceptance_checklist`
* **Intended move:** many→one H (instantiate)
* **Inputs (required):** `selected_items`, `anchor_phrase`, `artifact_kind="checklist"`
* **Output contract:** Output Item (H) MUST include:

  * `Acceptance checklist:` **≥ 10** checkbox lines
  * `Red flags:` **≥ 5** bullets
  * `Minimal trace:` list of selected item titles
* **Constraints:** Must include anchor phrase in at least two checklist items; red flags must be concrete failure patterns.
* **Logging expectations (names only):** `holologue.run_requested`, `credits.delta`, `holologue.completed`, `bond.proposals.presented`, `store.commit`
* **Prompt template:**

  ```text
  Create ONE acceptance checklist artifact focused on "{{anchor_phrase}}".
  Not summary-by-default: generate new actionable checklist items (no paraphrase recap).
  Output MUST include: Acceptance checklist (>=10 checkboxes), Red flags (>=5), Minimal trace.

  Quality gate: at least 3 checklist items must reference specific event names or object fields.
  Selected items:
  {{selected_items}}
  ```
* **Example instantiation:**

  ```text
  Create ONE acceptance checklist artifact focused on "lineage proof in ledger".
  Not summary-by-default: generate new actionable checklist items (no paraphrase recap).
  Output MUST include: Acceptance checklist (>=10 checkboxes), Red flags (>=5), Minimal trace.

  Quality gate: at least 3 checklist items must reference specific event names or object fields.
  Selected items:
  - Demo Golden Flow: Verify bond.run_requested < bond.executed and provenance links.
  - Core Data Objects: output items have provenance created_by="bond".
  ```

---

### Recipe 5: `holologue_translation_map`

* **Name / ID:** `holologue_translation_map`
* **Intended move:** many→one H (translate)
* **Inputs (required):** `selected_items`, `anchor_phrase`, `artifact_kind` (custom allowed)
* **Output contract:** Output Item (H) MUST include:

  * `Mapping:` at least **6** rows of `Source → Target` (bullets or table)
  * `Equivalences:` 3 bullets
  * `Non-equivalences:` 3 bullets
  * `Usage:` 3 bullets (“use this mapping to…”)
* **Constraints:** Must include anchor phrase; mapping must be grounded in terms present in inputs; no invented features.
* **Logging expectations (names only):** `holologue.run_requested`, `credits.delta`, `holologue.completed`, `bond.proposals.presented`, `store.commit`
* **Prompt template:**

  ```text
  Produce ONE translation/mapping artifact focused on "{{anchor_phrase}}".
  Not summary-by-default: create a mapping that helps implementation or reasoning.
  Output MUST include: Mapping (>=6), Equivalences (3), Non-equivalences (3), Usage (3).

  Quality gate: at least 2 mappings must mention concrete fields (e.g., output_item_id, selected_item_ids, episode.curated_item_ids).
  Selected items:
  {{selected_items}}
  ```
* **Example instantiation:**

  ```text
  Produce ONE translation/mapping artifact focused on "canon vs committed".
  Not summary-by-default: create a mapping that helps implementation or reasoning.
  Output MUST include: Mapping (>=6), Equivalences (3), Non-equivalences (3), Usage (3).

  Quality gate: at least 2 mappings must mention concrete fields (e.g., output_item_id, selected_item_ids, episode.curated_item_ids).
  Selected items:
  - Canon Policy: committed is storage-based; canonical is in curated projection.
  - Core Data Objects: objects are mutable snapshots; events are immutable audit trail.
  ```

---

### Recipe 6: `holologue_meta_recompose_artifacts`

* **Name / ID:** `holologue_meta_recompose_artifacts`
* **Intended move:** many→one H (meta; future-friendly)
* **Inputs (required):** `selected_items` (preferably includes at least 1 prior H), `anchor_phrase`, `artifact_kind` (custom allowed)
* **Output contract:** Output Item (H) MUST include:

  * `Unified artifact:` with a structured body (choose one: Plan, Spec Fragment, Checklist)
  * `Conflicts resolved:` at least **3** bullets (explicit resolutions)
  * `Open loops:` at least **3** bullets (TODOs)
* **Constraints:** Must be a recomposition, not concatenation; include anchor phrase; no full recaps.
* **Logging expectations (names only):** `holologue.run_requested`, `credits.delta`, `holologue.completed`, `bond.proposals.presented`, `store.commit`
* **Prompt template:**

  ```text
  Recompose the selected artifacts into ONE unified artifact focused on "{{anchor_phrase}}".
  Not summary-by-default: do not concatenate; resolve conflicts and produce a single usable output.
  Output MUST include:
  Unified artifact: (choose a structured format: Plan or Spec Fragment or Checklist)
  Conflicts resolved: (>=3)
  Open loops: (>=3)

  Quality gate: the Unified artifact must include at least 5 concrete constraints or steps.
  Selected items:
  {{selected_items}}
  ```
* **Example instantiation:**

  ```text
  Recompose the selected artifacts into ONE unified artifact focused on "event ordering guarantees".
  Not summary-by-default: do not concatenate; resolve conflicts and produce a single usable output.
  Output MUST include:
  Unified artifact: (choose a structured format: Plan or Spec Fragment or Checklist)
  Conflicts resolved: (>=3)
  Open loops: (>=3)

  Quality gate: the Unified artifact must include at least 5 concrete constraints or steps.
  Selected items:
  - Holologue Spec: completed only after output persisted; proposals after completion.
  - Demo Golden Flow: ledger must show ordering and lineage verification steps.
  ```

## 9) Proposal Generator Recipes — 2

> These generate **4 candidate Bond prompts** as suggestions (events only) either from a single Item (`bond.suggestions.presented`) or from a Holologue output/constellation (`bond.proposals.presented`). The prompts are content-shaped and request concrete outputs. Optional inferred `intent_type` labels may be included but are not required.

> Credits note (v0.1): proposal generation is **free by default** (no `credits.delta` required) because it does not execute an operator run that persists a generated output Item. If a build chooses to meter suggestions later, it must still use the `credits.delta` pattern from Section 4.

---

### Proposal Recipe 1: `proposal_pack_from_single_item`

* **Name / ID:** `proposal_pack_from_single_item`
* **Intended move:** proposals (for `bond.suggestions.presented`)
* **Inputs (required):** `item_title`, `item_body`, `anchor_phrase`
* **Output contract:** Output MUST be exactly **4** suggestions. Each suggestion MUST include:

  * `prompt_text` (1 sentence, 12–28 words)
  * optional `intent_type` (one of the 12 labels)
    Each `prompt_text` MUST:
  * include `{{anchor_phrase}}` OR a direct noun phrase from `{{item_title}}`
  * request a **concrete structured output** (checklist/steps/table/rules/tests)
  * be meaningfully distinct (no near-duplicates)
* **Constraints:** Avoid generic verbs (“elaborate” without constraints). No requirement for intent_type.
* **Logging expectations (names only):** `bond.suggestions.presented`
* **Prompt template:**

  ```text
  Generate 4 diverse Bond prompt suggestions from ONE Item.
  Item title: {{item_title}}
  Anchor phrase (must appear in each prompt OR a close noun phrase from title): "{{anchor_phrase}}"
  Item body:
  {{item_body}}

  Output JSON array of exactly 4 objects:
  [{ "prompt_text": "...", "intent_type": "optional" }, ...]

  Diversity rule: each prompt must request a different output shape (e.g., checklist vs decision record vs schema vs tests).
  Concrete rule: each prompt must specify at least one numeric constraint (e.g., ">=5 bullets", "6 steps", "table with 4 columns").
  ```
* **Example instantiation:**

  ```text
  Generate 4 diverse Bond prompt suggestions from ONE Item.
  Item title: My First Field Item
  Anchor phrase (must appear in each prompt OR a close noun phrase from title): "prove persistence"
  Item body:
  I want onboarding to prove this isn't chat by showing saved objects and a ledger trail.

  Output JSON array of exactly 4 objects:
  [{ "prompt_text": "...", "intent_type": "optional" }, ...]

  Diversity rule: each prompt must request a different output shape (e.g., checklist vs decision record vs schema vs tests).
  Concrete rule: each prompt must specify at least one numeric constraint (e.g., ">=5 bullets", "6 steps", "table with 4 columns").
  ```

---

### Proposal Recipe 2: `proposal_pack_from_holologue_output`

* **Name / ID:** `proposal_pack_from_holologue_output`
* **Intended move:** proposals (for `bond.proposals.presented`)
* **Inputs (required):** `anchor_phrase`, `artifact_kind`, `holologue_output_title`, `holologue_output_body`
* **Inputs (optional):** `selected_items` (to increase grounding)
* **Output contract:** Output MUST be exactly **4** suggestions. Each suggestion MUST:

  * reference the Holologue output (by reusing a noun phrase from `holologue_output_title/body`)
  * request a concrete follow-on that would plausibly generate a **Q, M, or D** Item via Bond execution
  * include at least one constraint (counts, required headings, table format, etc.)
  * be diverse (prefer: one expand, one clarify, one ground_in, one fork)
    Optional `intent_type` labels may be included to enforce diversity.
* **Constraints:** No auto-creating Bonds; this is suggestion output for an event only.
* **Logging expectations (names only):** `bond.proposals.presented`
* **Prompt template:**

  ```text
  Generate 4 diverse follow-on Bond prompts from a Holologue output artifact.
  Anchor phrase: "{{anchor_phrase}}"
  Artifact kind: {{artifact_kind}}
  Holologue output title: {{holologue_output_title}}
  Holologue output body:
  {{holologue_output_body}}

  (Optional) Selected constellation:
  {{selected_items}}

  Output JSON array of exactly 4 objects:
  [{ "prompt_text": "...", "intent_type": "optional" }, ...]

  Rules:
  - Each prompt must request a concrete output (checklist/plan/rules/tests/table) with a numeric constraint.
  - Each prompt must reuse at least one noun phrase from the Holologue output title/body.
  - Prompts must be non-duplicates.
  ```
* **Example instantiation:**

  ```text
  Generate 4 diverse follow-on Bond prompts from a Holologue output artifact.
  Anchor phrase: "quality gate"
  Artifact kind: checklist
  Holologue output title: Holologue artifact quality checklist
  Holologue output body:
  Checklist: ... include structure markers, novelty threshold, concrete payload marker ...

  Output JSON array of exactly 4 objects:
  [{ "prompt_text": "...", "intent_type": "optional" }, ...]

  Rules:
  - Each prompt must request a concrete output (checklist/plan/rules/tests/table) with a numeric constraint.
  - Each prompt must reuse at least one noun phrase from the Holologue output title/body.
  - Prompts must be non-duplicates.
  ```

## 10) Integration Notes (brief)

**Guided Tutorial usage**

* **Q→M (suggested Bond execution):**

  * Use Monologue recipes to generate 4 suggestions (via `proposal_pack_from_single_item`), selecting from recipe IDs like `clarify_to_testable_claim`, `expand_to_checklist`, etc.
  * Suggestions are emitted as `bond.suggestions.presented` (events only). User selects → `bond.draft_created` → `bond.run_requested` → `bond.executed` → output Item type `"M"`.
  * If Credits simulation is enabled, one or more `credits.delta` events may be appended during the run (e.g., spend/reward/refund).

* **Q→D (user-written Bond execution):**

  * Dialogue recipes are optional copy/paste helpers. User writes/edits `Bond.prompt_text` → `bond.draft_created` → `bond.run_requested` → `bond.executed` → output Item type `"D"`.
  * If Credits simulation is enabled, one or more `credits.delta` events may be appended during the run.

* **(Q,Q)→H (Holologue):**

  * Holologue recipes provide templates for `artifact_target_text` and structure contracts.
  * Log `holologue.run_requested`, then (on success) `holologue.completed`, then optionally `bond.proposals.presented`.
  * If Credits simulation is enabled, one or more `credits.delta` events may be appended during the run (e.g., spend then completion reward; or refund on failure).

**User edits**

* If the user edits a suggested prompt before creating the Bond, treat it as user-authored text:

  * Bond still may store `intent_type` optionally, but execution must never depend on it.
  * Consider recording `origin:"edited_suggestion"` in event `refs` (event-only; no new object fields required).

**Where recipes live**

* Recommended: a versioned static file in repo (e.g., `docs/recipes/spin_recipes.v0.1.json`) or a TypeScript constant module.
* Recipes are not persisted as Field objects in v0.1; only the resulting `prompt_text` and QDPIEvents are persisted.

## 11) Definition of Done (checklist)

* [ ] A recipe registry exists (static config or code constants) containing:

  * [ ] 8 Monologue recipes (Q→M)
  * [ ] 6 Dialogue recipes (Q→D)
  * [ ] 6 Holologue recipes (many→one H)
  * [ ] 2 proposal-generator recipes (4-pack prompts)
* [ ] A renderer exists for placeholders (`{{item_title}}`, `{{item_body}}`, `{{anchor_phrase}}`, `{{selected_items}}`, etc.).
* [ ] Anchor phrase extraction exists and ensures at least one anchor phrase is injected verbatim into rendered prompts.
* [ ] Proposal generation enforces:

  * [ ] exactly 4 prompts
  * [ ] diversity (different output shapes)
  * [ ] each prompt includes an anchor phrase / noun phrase from source
  * [ ] each prompt includes at least one numeric/structural constraint
* [ ] Executing a Bond does not require `intent_type`.
* [ ] Bond lifecycle invariant is preserved:

  * [ ] Draft Bond: `status:"draft"`, `output_item_id:null`
  * [ ] Executed Bond: `status:"executed"`, `output_item_id` set
* [ ] Holologue recipes enforce many→one artifact behavior and include anti-summary quality-gate instructions.
* [ ] Logging remains consistent with v0.1 policy:

  * [ ] state changes + key inspections only (QDPIEvents, with `direction`)
  * [ ] proposals are events-only
  * [ ] render/paint/layout events are debug-only
* [ ] (Optional) Credits simulation is compatible with the suite:

  * [ ] metered runs may emit `credits.delta` events (`qdpi:"Q"`, `direction:"system→field"`) with `refs.delta/balance_after/reason` and optional related IDs

## 12) Open Questions (5–10)

1. Should the system persist the chosen `recipe_id` in event `refs` (recommended) for debugging and A/B evaluation, or keep recipes entirely implicit?
2. How should anchor phrases be extracted deterministically (title n-grams vs keyword extraction), and should extraction be language-aware in v0.1?
3. Should proposal packs prefer a fixed diversity mapping (e.g., always include expands/clarifies/grounds_in/forks) or be purely content-driven?
4. For Dialogue (Q→D) outputs, should the system enforce a stricter structure marker set (roles/turns) to improve consistency?
5. For Holologue recipes, should `artifact_kind` fully determine the structure contract, or can the recipe override it (v0.1 recommendation: `artifact_kind` wins)?
6. Should there be a hard max length (characters/words) for `Bond.prompt_text` to avoid runaway prompts?
7. Should the UI expose optional `style_lens`, or keep it hidden until later to avoid tone drift?
8. How should recipes handle missing input bodies (empty Item body): output TODOs vs refuse to generate?
9. If Credits simulation is enabled, should `credits.delta` be emitted for suggestion/proposal generation, or only for operator runs that persist output Items?